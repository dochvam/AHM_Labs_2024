---
title: 'Lab 4: hierarchical site occupancy models'
author: "Ben Goldstein and Krishna Pacifici"
date: "Fall 2024"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# Install/load the necessary packages and 
tryCatch(library(devtools), 
         error = function(e) {
           install.packages("devtools")
           library(devtools)
         })
tryCatch(library(lubridate), 
         error = function(e) {
           install.packages("lubridate")
           library(lubridate)
         })
tryCatch(library(EcoData), 
         error = function(e) {
           devtools::install_github(repo = "TheoreticalEcology/EcoData", 
                                    dependencies = T, build_vignettes = T)
           library(EcoData)
         })
tryCatch(library(tidyverse), 
         error = function(e) {
           install.packages("tidyverse")
           library(tidyverse)
         })
tryCatch(library(nimble), 
         error = function(e) {
           install.packages("nimble")
           library(nimble)
         })
```


Topics:

 - Estimate an occupancy model with NIMBLE
 - Add a random intercept

### Data: gray fox on and around cannabis farms

In this lab, we'll be analyzing a real dataset collected by [Parker-Shames et al.](https://doi.org/10.60102/stacks-24003) This dataset was generated by a camera trapping survey that took place between 2016-2019 on and around small cannabis farms in southeastern Oregon, with the goal of understanding how this rapidly growing agricultural method affects wildlife space use. We're going to analyze occupancy at the scale of individual cameras, investigating variation in whether the area surveyed by a given camera is ever used by the animal. The survey collected data on a number of species, but we'll focus on gray fox.

First, we'll download the data.

```{r}
download.file("https://www.stacksjournal.org/wp-content/uploads/Articles/Parker-Shames-24003/Parker-Shames-24003-Dataset.zip", destfile = "Lab4_data.zip")

unzip("Lab4_data.zip")

cannabis_data <- read_csv("Parker-Shames-24003-Dataset/Parker-Shames-24003-Data.csv") %>% 
  mutate(Date = mdy(Date),
         Site = as.numeric(as.factor(Site)))

```

When dealing with data that represent replicate visits to closed sites, there are two typical ways that detection data might be organized, which we call "wide" and "long" formats. In wide format, you'd expect to see rows representing sites and columns represent visits, resulting in a (N x J) matrix. Wide format is great for understanding the breakdown of sites and visits, but isn't as conducive to handling multiple data in a common format. In long format, each row represents a visit within a site, and a separate column indicates which site a given visit belongs to, so detections are ultimately.

Our input data are stored in long format, with a single column representing deer detections. A second column called "Site" gives the name of each site. I've transformed "Site" to a numeric in the previous code chunk, so these just give values from 1:N. The columns are named after species, and the value in each column is either 0 or 1, indicating whether or not the species was detected *at all* during the 24-hour period associated with that row.

```{r}
# Number of visits to each site
head(count(cannabis_data, Site))

# Counts of fox detections per site
cannabis_data %>% 
  group_by(Site) %>% 
  summarize(fox = sum(fox)) %>% 
  ggplot() + 
  geom_col(aes(Site, fox))

# How many sites had at least one detection of fox?
cannabis_data %>% 
  group_by(Site) %>% 
  summarize(fox = sum(fox) > 0) %>% 
  .$fox %>% 
  table()
```


I'll do one additional data processing step to get these data ready for use in a NIMBLE model. Since the data are in long format, we have a lot of redundant information about sites repeated across rows for each site. Let's make a new data frame that just has one row per site, where we'll store data from all columns with only one unique value per site. 

```{r}
cannabis_data <- cannabis_data %>% 
  arrange(Site)

site_data <- cannabis_data %>% 
  distinct(
    Site, Reg1_intercept, Reg2_intercept, Reg3_intercept,
    dist_cannabis_sqrt, elev_scaled, forest_prop_scaled, 
    dist_paved_scaled
  )

```

### Fitting the occupancy model 

We want to understand how proximity to cannabis farms influences fox occupancy.

Broadly, the equations that define the model we want to fit are:

$$y_{i,j} \sim \text{Bernoulli}(z_i p_{i,j})$$

$$z_i \sim \text{Bernoulli}(\psi_i)$$

$$\text{logit}(p_{i,j}) = \alpha_0 + \alpha_1 w_{i,j,1} + ...$$

$$\text{logit}(\psi_{i}) = \beta_0 + \beta_1 \text{dist_cannabis_sqrt}_i + \beta_2x_{i,2} + ...$$

We have a number of incidental covariates that we think might influence the occupancy probability.

Design questions:
 - Should we start by throwing in all covariates, or start with a simple model and add complexity?
 - Should we include an effect of Region? Should it be a fixed or random effect?


### Modeling workflow

I provide code to specify and estimate a model including only the effect of distance to cannabis on gray fox occupancy. Modify the model to include a random effect of region on occupancy, and a fixed effect of Julian date (`jdate`) on detection.

```{r}

# Define the model:
code <- nimbleCode({
  
  # Site-level values
  for (i in 1:nsite) {
    logit(psi[i]) <- beta0 + beta1 * dist_cannabis_sqrt[i]
    z[i] ~ dbern(psi[i])
  }
  
  # Observation-level values
  for (o in 1:nobs) {
    logit(p[o]) <- alpha0
    y[o] ~ dbern(z[site[o]] * p[o])
  }
  
  # Priors
  beta0 ~ dnorm(0, sd = 5)
  beta1 ~ dnorm(0, sd = 5)
  alpha0 ~ dnorm(0, sd = 5)
})

# Build the model:
occ_model <- nimbleModel(
  code = code,
  constants = list(
    nobs = nrow(cannabis_data), 
    nsite = nrow(site_data),
    site = cannabis_data$Site
  ), 
  data = list(
    y = cannabis_data$fox,
    dist_cannabis_sqrt = site_data$dist_cannabis_sqrt
  ),
  inits = list(
    beta0 = 0, beta1 = 0, alpha0 = 0, z = rep(1, nrow(site_data))
  )
)

```
Now we run the MCMC to get posterior distributions of our three parameters.

```{r}
mcmcConf <- configureMCMC(occ_model)
mcmc <- buildMCMC(mcmcConf)

complist <- compileNimble(occ_model, mcmc)

samples <- runMCMC(complist$mcmc, niter = 10000, nburnin = 5000,
                   nchains = 3, samplesAsCodaMCMC = TRUE)

summary <- MCMCvis::MCMCsummary(samples)

View(summary)
```


